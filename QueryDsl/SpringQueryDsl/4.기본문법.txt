=========== 검색 조건 쿼리 ===========
// JPQL 이 제공하는 모든 검색 조건을 제공함
    .eq()           : =
    .ne()           : !=
    .eq().not()     : !=
    .isNotNull()    : is not null
    .in(,)          : age in (10,20)
    .notIn(,)       : age not in (10,20)
    .between(,)     : age between 10, 30
    .goe()          : >=
    .gt()           : >
    .loe()          : <=
    .lt()           : <
    .like()         : like 검색
    .contains()     : like %member%
    .startsWith()   : like member%

// and 조건을 풀수있는 방법 두가지
1. .and() 로 메서드체인
2. 쉼표로 끊어서 파라미터 처리

=========== 결과 조회 ===========
.fetch()            : 리스트 조회, 데이터 없으면 빈 리스트 반환
.fetchOne()         : 단건 조회, 결과가없으면 Null, 결과가 둘 이상이면 NonUniqueResultException
.fetchFirst()       : limit(1).fetchOne() 과 동일
.fetchResults()     : 페이징 정보 포함, total count 쿼리 추가 실행
.fetchCount()       : count() 쿼리로 변경해서 count 수만 조회

=========== 정렬 ===========
.orderBy(
    member.age.desc(),
    member.username.asc().nullsLast()   // 회원 이름이 없으면 마지막에 출력 (nulls last)
)                                       // 반대로 이름이 없으면 첫번째로 출력도 있음. nullsFirst()

=========== 페이징 ===========
.offset(1)                     // 끊어올 쿼리의 시작위치 (offset --> 0부터 시작임)
.limit(3)                      // offset 으로부터 몇개를 가져올 것인지
.fetch() 혹은 .fetchResults()   // fetch() 는 count 쿼리 x, .fetchResults() 는 count 쿼리 O

=========== 집합 ===========
.select(member.age.sum(), member.username)    // select 에서 조회를 할 떄, 단일타입이 아닌, 다중타입이면 리턴타입이 Tuple 이다.
.from(member)

.select(team.name, member.age.avg())          // select 절에서 단일타입이 아닌, 다중타입 --> 리턴타입 Tuple
    .from(member)
    .join(member.team, team)
    .groupBy(team.name)                       // Team 의 이름으로 그룹 (groupBy)
    .having(team.name.eq("~@#!@"))            // 그룹화된 결과를 제한할때 사용하는 having
    .fetch();

=========== JOIN ===========
// inner join
.selectFrom(member)
.innerJoin(member.team, team)                  // 그냥 .join() 과 동일 (innerJoin(), join() 동일)
.where(team.name.eq("teamA"))

// left join
.selectFrom(member)
.leftJoin(member.team, team)                   // 그냥 leftJoin()
.where(team.name.eq("teamA"))

// theta join
.select(member)
.from(member, team)                            // theta 조인(막조인)은 from 절에 QClass 타입을 두개 나열하는 것임. (쉽게말해 모든 회원과 팀을 가져와서 조인하는 것임)
.where(member.username.eq(team.name))

