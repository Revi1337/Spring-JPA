// 프록시 - 이걸 왜 써야할까?
Member -> Team (멤버가 팀을 참조하는 상황이고 비즈니스로직은 팀을 출력을 잘 사용하지않음 - Member 를 조회할때 Team 도 함께 조회해야할까?)
해결방법으로는 즉시로딩과(Eager), 지연로딩(LazyFetch) 이 있음. 하지만 이것을 깊이있게 이해하려면 JPA 의 프록시라는 개념을 명확하게 알 필요가 있음.

// 프록시 기초
- em.find() vs em.getReference()
- em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
- em.getReference : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회 (이게 뭔개소린가 싶겠지만 DB 에 쿼리가 안나가는데, 객체가 조회가 되는것임.)

// 프록시 특징
- 실제 클래스를 상속 받아서 만들어짐
- 실제 클래스와 겉 모양이 같음
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨. (이론상)
- 프록시 객체는 실제 객체의 참조(target) 을 보관함
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메서드를 동일하게 호출함.

// 프록시의 특징
- 프록시 객체는 처음 사용할 떄 한번만 초기화 (getReferencer() 가 초기화를 하는것이 아닌, .getUsername(). 즉, 프록시객체를 사용할때 그때 초기화됨)
- 프록시 객체의 초기화 요청은 영속성컨텍스트를 통해 이루어짐.
- 프록시 객체를 초기화할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근이 가능해지는 것임.
- 프록시 객체는 원본 엔티티를 상속받음. 따라서 타입체크시 주의바람 (== 비교실패, 대신 instanceof 사용)
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference() 를 호출해도 실제엔티티 반환
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일때, 프록시를 초기화하면 문제발생. (하이버네이트는 LazyInitializationException 을 던짐.)

// 프록시의 확인
- 프록시 인스턴스의 초기화 여부 확인 - util = entityManagerFactory.getPersistenceUnitUtil(); util.isLoaded(Object entity)
- 프록시 클래스 확인 방법 - entity.getClass().getName()
- 프록시 강제 초기화 - Hibernate.initialize(entity);
