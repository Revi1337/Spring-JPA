// 단방향
Member --> Team (o)
Team --> Member (x)

// 양방향
Member --> Team (o)
Team --> Member (o)

// 양방향 매핑
- 사실, 양방향매핑을 한다고해도 테이블에서의 연관관계는 단방향 매핑했을때와 변화가 없음.
  * 두 테이블이 양방향일 경우
    - MEMBER 가 속한 TEAM 을 알고싶으면 (MEMBER 테이블의 TEAM_ID(FK) 와 TEAM 의 TEAM_ID(PK) 를 조인하면되고)
    - TEAM 에 속한 MEMBER 들을 알고싶으면 (TEAM 테이블의 TEAM_ID(PK) MEMBER 의 TEAM_ID(FK) 를 조인하면 하면 되는거임.)
  ----> 따라서 테이블에서의 연관관계에서는 방향이라는 개념자체가 없음. 그냥 FK 하나만 집어넣으면 양쪽으로 조인해서 서로의 연관을 알 수 있음.
- 하지만, 문제는 객체에서의 연관관계임. Member 에서 Team 을 참조할수 있지만, Team 에서 Member 를 참조할수없음. --> 이를해결하기 위해 Team 에서 Members 라는 리스트를 넣어줘야함.

// 씹중요! 연관관계의 주인과 mappedBy ( JPA 멘탈붕괴 난이도..? )
- 객체와 테이블간에 연관관계를 맺는 차이를 이해해야 함.

// 객체와 테이블이 관계를 맺는 차이
- 객체에서의 연관관계 = 2개
    Member -> Team (단방향)
    Team -> Member (단방향)
- 테이블에서의 연관관계 = 1개
    Member <-> Team (방향이없음(양방향))

// 테이블의 양방향 연관관계
- 테이블은 외래키 하나로 두 테이블의 연관관계를 관리
- MEMBER.TEAM_ID(FK) 한개로 TEAM 과 MEMBER 테이블의 연관관계를 가짐(양쪽으로 조인할 수 있음.)
  EX)
  MEMBER 가 속한 TEAM 을 알고싶으면 (MEMBER 의 TEAM_ID(FK) 와 TEAM 의 TEAM_ID(PK) 를 조인하면되고)
  TEAM 에 속한 MEMBER 들을 알고싶으면 (TEAM 의 TEAM_ID(PK) MEMBER 의 TEAM_ID(FK) 를 조인하면 하면 되는거임.)
  --> MEMBER.TEAM_ID(FK) 한개로 TEAM 과 MEMBER 테이블의 연관관계를 관리하고있음.

// 객체의 양방향 연관관계
- 풀어서 설명하면, 객체의 양방향관계는 사실 양방향관계가 아니라 서로 다른 단방향 관계 2개임.
- 객체를 양방향을 참조하려면 단방향 연관관계를 2개 만들어야 함.

// 연관관계의 주인 (Owner)
양방향 매핑에서 생기는 규칙
- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
- 연관관계의 주인만이 외래키를 관리 (등록, 수정)
- 주인이 아닌쪽은 읽기만 가능 (가짜매핑)
- 주인(진짜매핑)은 mappedBy 속성 사용 X           <-------- 중요
- 주인이 아니면 mappedBy 속성으로 주인을 지정해주어야함. mappedBy 뜻자체가 ~에게 되었어라는 의미(주인이 아니라는 의미.)  <-------- 중요

// 누구를 주인으로?
- 여기에는 답이 있는데, 외래키가 있는 곳을 엔티티를 주인으로 정하는 것임. (그냥 @ManyToOne 쪽이 주인으로 삼으면 됨. == @OneToMany 쪽에서 mappedBy 를 걸면됨.)
  어짜피 DB 입장에서 외래키(FK)가 있는곳은 @ManyToOne(N : 1) 쪽일수밖에없음. --> 그 말은 곧, DB 의 N 쪽이 무조건 연관관계의 주인이되는것임.
- 여기서는 Member.team 이 연관관계의 주인.