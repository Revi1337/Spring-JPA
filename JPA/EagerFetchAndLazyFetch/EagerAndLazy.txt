// 즉시로딩 지연로딩
1. Member 를 조회할때 Team 도 함께 조회해야 할까? (Member -> Team : 멤버가 팀을 참조하는 상황)
- 주로 member 정보만 사용하는 비즈니스 로직이라고하면 -->  Member 를 조회할때 Team 까지 조인하면 굉장히 성능낭비임 --> 따라서 지연로딩을 써서 Member 를 조회할때, Team 까지 조회하는 성능 낭비를 방지하는 방향을 채택해야함.
2. Member 를 조회할때 Team 도 함께 조회해야 할까? (Member -> Team : 멤버가 팀을 참조하는 상황)
- 주로 Member 와 Team 을 같이 사용하는 비지니스 로직이라고하면 --> Member 를 조회하는데, 따로 Team 까지 조회하면 성능이 안나옴 --> 따라서 즉시로딩을 써서 Member 를 조회할때, Team 까지 조회하여, 쿼리가 두번 나가지 않게 하는 방향을 채택해야함.

// 프록시와 즉시로딩 주의. (진짜 ㅈㄴ 중요한 내용)
- 가급적 다 지연로딩만 사용해야한다. (특히 실무에서 즉시로딩은 절대 써선 안됨.) --> 테이블이 많아질수록 많아질수록 find 할떄 모든 테이블이 조인됨.ㅋㅋㅋ
- 즉시로딩을 적용하면 예상하지 못한 SQL 이 발생함.
- 즉시로딩은 JPQL 에서 N+1 문제를 일으킴
- @ManyToOne, @OneToOne 같이 ~ToOne 시리즈들은 기본이 EAGER 로 설정되어있음 --> LAZY 로 바꿔야함.
- @OneToMany, @ManyToMany 같이 ~toMany 시리즈들은 기본이 LAZY 로 설정되어있음 --> 내비두면 됨.
* 결론 연관관계 싹다 Lazy 로 박고, 필요한것만 fetch join 으로 갖오고는 방법을 써야함.

// 지연 로딩 활용  (굉장히이론적인 내용일뿐 실무에서는 다 지연로딩으로 덕지덕지 발라야함을 잊지않아야함.)
Member(N) : Team(1)
Member(1) : Order (N)
Order(N) : Product(1)
- Member 와 Team 은 자주 함께 사용 --> 즉시 로딩
- Member 와 Order 는 가끔 사용 --> 지연 로딩
- Order 와 Product 는 자주 함께 사용 --> 즉시 로딩

// 결론
* 모든 연관관계에 지연 로딩을 사용해라
* 실무에서 즉시로딩을 사용하지 마라
* JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라(뒤에서 설명)
* 즉시로딩은 상상하지 못한 쿼리가 나간다.