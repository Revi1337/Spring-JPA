// 영속성 관리
- JPA 를 이해하려면 영속성 컨텍스트 를 이해해야함.

// JPA 에서 가장 중요한 2가지
1. 객체와 관계형 데이터베이스 매핑하기 (Object Relational Mapping)
2. 영속성 컨텍스트

// 영속성 컨텍스트
- JPA 를 이해하는데 가장 중요한 용어
- "엔티티를 영구 저장하는 환경" 이라는 뜻
- EntityManger.persist(entity); --> 영속성 컨텍스트를 통해서 entity 를 영속화한다는 것임. entity DB 에 저장한다는 뜻이 아니라, 영속성 컨텍스트에 저장한다는 뜻임.

// 엔티티 매니저? 영속성 컨텍스트?
- 영속성 컨텍스트는 논리적인 개념
- 눈에 보이지 않음.
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근!! <- 중요

// 엔티티의 생명주기
- 비영속 (new / transient) : 영속성 컨텍스트와 전혀 관계없는 새로운 상태 --> 객체를 생성한 상태. (ex. Member member = new Member(1L, "dummy");)
- 영속 (managed) : 영속성 컨텍스트에 관리되는 상태 --> EntityManager 를 얻어와서 .persist(member) 하여 객체를 저장한 상태. --> 영속성 컨텍스트에 저장.
- 준영속 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 (removed) : 삭제된 상태

// 영속성 컨텍스트의 이점
- 애플리케이션 <--- JPA ---> DB  : 버퍼링과 캐시와같은 이점을 누릴 수 있음.
1. 1차 캐시 : 한번 조회했던것을 또 조회하면 쿼리가 날라가지않음 (물론 동일한 트랜잭션 안에서임)
2. 동일성을 보장
3. 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind) : 버퍼링
4. 변경 감지 (Dirty Checking)
5. 지연 로딩 (Lazy Loading)

// 영속성 컨텍스트 구조
- 1차 캐시, 쓰기 지연 SQL 저장소

// 1차 캐시 구조
- PKI, Entity, SnapShot

// 엔티티 등록
- persist(memberA) 를 하면 memberA 가 1차캐시에 들어과 동시에, JPA 가 memberA 를 분석하고 INSERT 쿼리를 생성하여 쓰기 지연 SQL 저자소에 쌓아둠. (이떄까지 DB에 뭘 넣는것이 없음)
- persist(memberB) 를 하면 memberA 와 마찬가지로, 1차 캐시에 들어가고 INSERT 문이 쓰기 지연 SQL 저장소에 쌓임.
- entityTransaction.commit(). 즉, 커밋하는 시점에, 쓰기 지연 SQL 저장소에 있던 쿼리들이 Flush 되면서 실제 DB 에 쿼리가 날라가고 반영되는 것임.

// 엔티티 변경
- 사실, 영속성 컨텍스트의 1차 캐시안에는 PKI, Entity, SnapShot 이 있는데, 스냅샷은 값을 읽어온 최초 시점의 상태를 의미함.
- JPA 는 트랜잭션의 커밋 시점에 내부적으로 Flush 가 호출이 되면서 Entity 와 스냅샷을 비교함. 여기서 값의 변경이 확인되면 UPDATE 쿼리를 쓰기지연 SQL 저장소에 만들어둠.
- 그리고 커밋시점에 UPDATE 를 반영하고 커밋하게 되는 것임.
- 그냥 JPA 는 값을 바꾸면 트랜잭션이 커밋되는 시점에 변경을 반영하는구나라고 생각하면 됨.

// 플러시
- 영속성 컨텍스트의 변경내용을 DB 에 반영하는 것을 말함.
- 트랜잭션을 커밋하거나 쿼리를 실행할때 플러시가 일어남.
- 직접 플러시 할 수 있다.

// 플러시 발생하면 무슨일이 생기냐..
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 DB 에 전송 (등록, 수정, 삭제 쿼리를 쏵 보냄.)
- 플러시가 발생한다고해서 트랜잭션이 바로 커밋되는것이 아니고, 보내고 그리고 DB 를 커밋함

// 영속성 컨텍스트를 플러시하는 방법
- em.flush() - 직접호출
- 트랜잭션 커밋 - 플러시 자동호출
- JPQL 쿼리 실행 - 플러시 자동호출

// 플러시 (Flush) 는!!
- 영속성 컨텍스트를 비우는 것이 아님. (이름땜에 오해하면 안됨.)
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화하는것으로 생각하면됨.
- 트랜잭션 이라는 작업 단위가 중요 --> 커밋 직전에만 동기화하면 다른 이슈는 없음.

// 준영속
- 영속상태가 되는 케이스는 아래 두가지가 있음.
1. persist() 로 영속성 컨텍스트에 올리는 방법.
2. find() 를 실행했는데, 영속성 컨텍스트의 1차캐시에 없어, DB 에 쿼리를 날려 조회 후, 객체를 갖고와서 영속성 컨텍스트의 1차캐시에 올려 영속시키는 방법.
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)되는 것.
- 영속성 컨텍스트가 제공하는 기능을 사용 못함.

// 준영속 상태로 만드는 방법
1. entityManager.detach(entity) : 특정 엔티티만 준영속 상태로 전환
2. entityManager.clear() : 영속성 컨텍스트를 완전히 초기화
3. entityManager.close() : 영속성 컨텍스트를 종료



